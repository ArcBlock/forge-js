{"version":3,"sources":["../src/client.js"],"names":["camelCase","require","snakeCase","errorCodes","transactions","multiSignTxs","createMessage","getMessageType","bytesToHex","toBase58","toBase64","toHex","debug","name","GraphQLClientBase","aliases","PokeTx","GraphQLClient","constructor","config","_initTxMethods","getTxSendMethods","map","x","getTxEncodeMethods","getTxSignMethods","getTxMultiSignMethods","getType","fn","decodeTx","buffer","Transaction","deserializeBinary","toObject","forEach","txEncodeFn","tx","wallet","delegatee","address","from","toAddress","pk","publicKey","nonce","Date","now","chainId","_chainId","info","getChainInfo","network","signatures","Array","isArray","signaturesList","itx","typeUrl","value","type","txObj","delegator","signature","Buffer","txToSignBytes","serializeBinary","object","encodeMethod","__tx__","txSendFn","encoded","res","sign","txBytes","txStr","Promise","resolve","reject","hash","sendTx","err","errors","code","message","error","_createResponseError","sendMethod","_formatEncodedTx","encoding","txSignFn","signMethod","includes","txMultiSignFn","data","Error","unshift","signer","multiSignMethod","method","default","trim","module","exports"],"mappings":"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","file":"client.js","sourcesContent":["/* eslint-disable no-underscore-dangle */\nconst camelCase = require('lodash/camelCase');\nconst snakeCase = require('lodash/snakeCase');\nconst errorCodes = require('@arcblock/forge-proto/lib/status_code.json');\nconst { transactions, multiSignTxs } = require('@arcblock/forge-proto/lite');\nconst { createMessage, getMessageType } = require('@arcblock/forge-message/lite');\nconst { bytesToHex, toBase58, toBase64, toHex } = require('@arcblock/forge-util');\n\nconst debug = require('debug')(require('../package.json').name);\n\nconst GraphQLClientBase = require('./base');\n\n// Alias methods\nconst aliases = {\n  PokeTx: 'checkin',\n};\n\n/**\n * An http client that can read/write data to a forge powered blockchain node, can be used in both node.js and browser.\n *\n * Please note that, due to internal implementation of google-protobuf, all `repeated fields` names are suffixed with `List`\n *\n * @class\n * @example\n * const GraphQLClient = require('@arcblock/graphql-client');\n *\n * const client = new GraphQLClient('https://argon.abtnetwork.io/api');\n * // const client = new GraphQLClient({ endpoint: 'https://argon.abtnetwork.io/api' });\n *\n * const res = await client.getChainInfo();\n */\nclass GraphQLClient extends GraphQLClientBase {\n  /**\n   * Create an instance of GraphQLClient\n   *\n   * @constructor\n   * @param {object|string} config - config object, if a string passed, will be used as the endpoint\n   * @param {string} [config.endpoint='http://localhost:8210/api'] - the graphql endpoint\n   * @param {string} [config.chainId=''] - the chainId of the network\n   * @see GraphQLClient#getQueries\n   * @see GraphQLClient#getMutations\n   * @see GraphQLClient#getSubscriptions\n   * @see GraphQLClient#getTxSendMethods\n   * @see GraphQLClient#getTxEncodeMethods\n   */\n  constructor(config = 'http://localhost:8210/api') {\n    super(config);\n    this._initTxMethods();\n  }\n\n  /**\n   * List all transaction send methods\n   * Each method can send one kind of transactions supported by forge core, such as `DeclareTx`, `PokeTx`\n   *\n   * @method\n   * @returns {Array<string>} method name list\n   */\n  getTxSendMethods() {\n    return transactions.map(x => camelCase(`send_${x}`));\n  }\n\n  /**\n   * List all transaction encode methods, each method can be used to encode transaction to buffer and object\n   *\n   * @method\n   * @returns {Array<string>} method name list\n   */\n  getTxEncodeMethods() {\n    return transactions.map(x => camelCase(`encode_${x}`));\n  }\n\n  /**\n   * List all transaction sign methods, each method can be used to sign transaction to an object\n   *\n   * @method\n   * @returns {Array<string>} method name list\n   */\n  getTxSignMethods() {\n    return transactions.map(x => camelCase(`sign_${x}`));\n  }\n\n  /**\n   * List all transaction multi sign methods, each method can be used to do multi sign a transaction\n   *\n   * @method\n   * @returns {Array<string>} method name list\n   */\n  getTxMultiSignMethods() {\n    return multiSignTxs.map(x => camelCase(`multi_sign_${x}`));\n  }\n\n  /**\n   * Get protobuf message class by name, only supports forge-built-in types\n   *\n   * @method\n   * @param {string} x\n   * @returns {class|null} message type\n   */\n  getType(x) {\n    return getMessageType(x).fn;\n  }\n\n  /**\n   * Decode transaction buffer to an object\n   *\n   * @method\n   * @param {buffer} buffer\n   * @returns {object} transaction object\n   */\n  decodeTx(buffer) {\n    const Transaction = this.getType('Transaction');\n    return Transaction.deserializeBinary(buffer).toObject();\n  }\n\n  _initTxMethods() {\n    transactions.forEach(x => {\n      /**\n       * Encode a transaction\n       *\n       * @param {object} input\n       * @param {object} input.tx - data of the transaction\n       * @param {object} input.tx.itx - the actual transaction object\n       * @param {object} [input.tx.from] - the sender address, can be derived from wallet\n       * @param {object} [input.tx.nonce] - the tx nonce, defaults to Date.now if not set\n       * @param {object} [input.tx.chainId] - the chainId\n       * @param {object} [input.tx.signature] - the chainId\n       * @param {object} [input.tx.signatures] - the chainId\n       * @param {object} input.wallet - the wallet used to sign the transaction, either a forge managed wallet or user managed wallet\n       * @param {object} input.delegatee - the wallet address that delegated permissions to the `input.wallet` address\n       * @returns Promise\n       */\n      const txEncodeFn = async ({ tx, wallet, delegatee }) => {\n        // Determine sender address\n        const address = tx.from || wallet.toAddress();\n        const pk = tx.pk || wallet.publicKey;\n\n        // Determine chainId & nonce, only attach new one when not exist\n        const nonce = typeof tx.nonce === 'undefined' ? Date.now() : tx.nonce;\n        let chainId = tx.chainId || this._chainId;\n        if (!chainId) {\n          const { info } = await this.getChainInfo();\n          chainId = info.network;\n          this._chainId = chainId;\n        }\n\n        // Determine signatures for multi sig\n        let signatures = [];\n        if (Array.isArray(tx.signatures)) {\n          // eslint-disable-next-line prefer-destructuring\n          signatures = tx.signatures;\n        }\n        if (Array.isArray(tx.signaturesList)) {\n          signatures = tx.signaturesList;\n        }\n\n        // Determine itx\n        let itx = null;\n        if (tx.itx.typeUrl && tx.itx.value) {\n          // eslint-disable-next-line prefer-destructuring\n          itx = tx.itx;\n        } else {\n          itx = { type: x, value: tx.itx };\n        }\n\n        const txObj = createMessage('Transaction', {\n          from: tx.delegator ? address : delegatee || address,\n          nonce,\n          pk,\n          chainId,\n          signature: tx.signature || Buffer.from([]),\n          signatures,\n          delegator: tx.delegator || (delegatee ? address : ''),\n          itx,\n        });\n        const txToSignBytes = txObj.serializeBinary();\n\n        debug(`encodeTx.${x}.txObj`, txObj.toObject());\n\n        return { object: txObj.toObject(), buffer: Buffer.from(txToSignBytes) };\n      };\n\n      const encodeMethod = camelCase(`encode_${x}`);\n      txEncodeFn.__tx__ = encodeMethod;\n      this[encodeMethod] = txEncodeFn;\n\n      /**\n       * Send a transaction\n       *\n       * @param {object} input\n       * @param {object} input.tx - data of the transaction\n       * @param {object} input.tx.itx - the actual transaction object\n       * @param {object} [input.tx.from] - the sender address, can be derived from wallet\n       * @param {object} [input.tx.nonce] - the tx nonce, defaults to Date.now if not set\n       * @param {object} [input.tx.chainId] - the chainId\n       * @param {object} [input.tx.signature] - the chainId\n       * @param {object} [input.tx.signatures] - the chainId\n       * @param {object} input.wallet - the wallet used to sign the transaction, either a forge managed wallet or user managed wallet\n       * @param {object} [input.signature] - the signature of the tx, if this parameter exist, we will not sign the transaction\n       * @param {object} input.delegatee - the wallet address that delegated permissions to the `input.wallet` address\n       * @returns Promise\n       */\n      const txSendFn = async ({ tx, wallet, signature, delegatee }) => {\n        let encoded;\n        if (signature) {\n          encoded = tx;\n          encoded.signature = signature;\n        } else if (tx.signature) {\n          const res = await txEncodeFn({ tx, wallet, delegatee });\n          encoded = res.object;\n        } else {\n          const res = await txEncodeFn({ tx, wallet, delegatee });\n          // eslint-disable-next-line prefer-destructuring\n          encoded = res.object;\n          encoded.signature = wallet.sign(bytesToHex(res.buffer));\n        }\n\n        const txObj = createMessage('Transaction', encoded);\n        const txBytes = txObj.serializeBinary();\n        const txStr = toBase64(txBytes);\n        debug(`sendTx.${x}.txObj`, txObj.toObject());\n\n        return new Promise(async (resolve, reject) => {\n          try {\n            const { hash } = await this.sendTx({ tx: txStr });\n            resolve(hash);\n          } catch (err) {\n            if (Array.isArray(err.errors)) {\n              const code = err.errors[0].message;\n              if (errorCodes[code]) {\n                const error = this._createResponseError(code, x);\n                error.errors = err.errors;\n                reject(error);\n                return;\n              }\n            }\n\n            reject(err);\n          }\n        });\n      };\n\n      const sendMethod = camelCase(`send_${x}`);\n      txSendFn.__tx__ = sendMethod;\n      this[sendMethod] = txSendFn;\n      // Add alias\n      if (aliases[x]) {\n        this[aliases[x]] = txSendFn;\n      }\n\n      const _formatEncodedTx = async (tx, encoding) => {\n        if (encoding) {\n          const { buffer: txBytes } = await txEncodeFn({ tx });\n          if (encoding === 'base64') {\n            return toBase64(txBytes);\n          }\n          if (encoding === 'base58') {\n            return toBase58(txBytes);\n          }\n          if (encoding === 'base16' || encoding === 'hex') {\n            return toHex(txBytes);\n          }\n          return txBytes;\n        }\n\n        return tx;\n      };\n\n      // Generate transaction signing function\n      const txSignFn = async ({ tx, wallet, delegatee, encoding = '' }) => {\n        if (tx.signature) {\n          delete tx.signature;\n        }\n\n        const { object, buffer } = await txEncodeFn({ tx, wallet, delegatee });\n        object.signature = wallet.sign(buffer);\n\n        return _formatEncodedTx(object, encoding);\n      };\n      const signMethod = camelCase(`sign_${x}`);\n      txSignFn.__tx__ = signMethod;\n      this[signMethod] = txSignFn;\n\n      // TODO: verify existing signatures before adding new signatures\n      // Generate transaction multi sign function\n      if (multiSignTxs.includes(x)) {\n        const txMultiSignFn = async ({ tx, wallet, delegatee, data, encoding = '' }) => {\n          if (typeof wallet.toAddress !== 'function') {\n            throw new Error('Multisig requires a valid wallet');\n          }\n          tx.signaturesList = tx.signatures || tx.signaturesList || [];\n          tx.signaturesList.unshift({\n            pk: wallet.publicKey,\n            signer: wallet.toAddress(),\n            delegator: delegatee || '',\n            data,\n          });\n\n          const { object, buffer } = await txEncodeFn({ tx, wallet });\n          object.signaturesList[0].signature = wallet.sign(bytesToHex(buffer));\n          return _formatEncodedTx(object, encoding);\n        };\n        const multiSignMethod = camelCase(`multi_sign_${x}`);\n        txMultiSignFn.__tx__ = multiSignMethod;\n        this[multiSignMethod] = txMultiSignFn;\n      }\n    });\n  }\n\n  _createResponseError(code, method) {\n    const type = snakeCase(method);\n    const message = (errorCodes[code][type] || errorCodes[code].default || code).trim();\n    const error = new Error(`${code}: ${message}`);\n    error.code = code;\n    error.type = type;\n    return error;\n  }\n}\n\nmodule.exports = GraphQLClient;\n"]}