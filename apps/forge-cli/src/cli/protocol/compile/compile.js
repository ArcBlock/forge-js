const fs = require('fs');
const path = require('path');
const shell = require('shelljs');
const yaml = require('yaml');
const { symbols } = require('core/ui');
const { isDirectory, isFile } = require('core/env');

async function ensureForgeCompiler() {
  const { stdout } = shell.which('forge-compiler');
  if (stdout && fs.existsSync(stdout.trim())) {
    return stdout.trim();
  }

  // FIXME: if not found, download and install forge-compiler directly
  throw new Error('forge-compiler not found');
}

async function ensureJavascriptTools() {
  // FIXME: ensure all command lines tools need to compile javascript files
}

async function compileElixir({ targetDir, config, configFile, outputPrefix }) {
  shell.echo(`${symbols.info} generating elixir language support:`);

  const compiler = await ensureForgeCompiler();
  const { name } = config;

  // 0. prepare compile dir
  const targetExDir = path.join(targetDir, name, 'elixir');
  shell.exec(`mkdir -p ${targetExDir}`);

  shell.exec(`${compiler} ${configFile} ${targetExDir}`, { silent: true });
  shell.echo(
    `${symbols.success} elixir itx generated: ${targetExDir.replace(
      outputPrefix,
      ''
    )}/${name}/${name}.itx.json`
  );
  shell.echo('');
}

async function compileJavascript({ sourceDir, targetDir, config, protoFile, outputPrefix }) {
  shell.echo(`${symbols.info} generating javascript language support:`);

  const { name, type_urls: typeUrls } = config;
  const targetJsDir = path.join(targetDir, name, 'javascript');
  shell.exec(`mkdir -p ${targetJsDir}`);

  shell.exec(
    `grpc_tools_node_protoc --proto_path=${sourceDir} --js_out=import_style=commonjs,binary:${targetJsDir} --plugin=protoc-gen-grpc=\`which grpc_tools_node_protoc_plugin\` ${protoFile}`
  );
  shell.echo(
    `${symbols.success} protobuf js generated: ${targetJsDir.replace(
      outputPrefix,
      ''
    )}/protocol_pb.js`
  );
  shell.exec(`pbjs -p ${sourceDir} -t json -o ${targetJsDir}/protocol_spec.json ${protoFile}`);
  shell.echo(
    `${symbols.success} json spec generated: ${targetJsDir.replace(
      outputPrefix,
      ''
    )}/protocol_spec.json`
  );

  // 3. generate type urls for javascript
  const results = Object.keys(typeUrls || {}).reduce((obj, url) => {
    const type = typeUrls[url].split('.').pop();
    obj[type] = url;
    return obj;
  }, {});
  fs.writeFileSync(`${targetJsDir}/protocol_url.json`, JSON.stringify(results));
  shell.echo(
    `${symbols.success} type urls json generated: ${targetJsDir.replace(
      outputPrefix,
      ''
    )}/protocol_url.json`
  );

  // 4. generate javascript entry file
  fs.writeFileSync(
    `${targetJsDir}/index.js`,
    `// Generated by forge-cli
const { addProvider } = require('@arcblock/forge-message');
const types = require('./protocol_pb.js');
const specs = require('./protocol_spec.js');
const urls = require('./protocol_url.js');

addProvider({ types }, specs, urls);

module.exports = { types, specs, urls };
`
  );
  shell.echo(
    `${symbols.success} javascript entry file generated: ${targetJsDir.replace(
      outputPrefix,
      ''
    )}/index.js`
  );
  shell.echo('');
}

async function main({ args: [dir], opts: { targets = 'elixir,javascript' } }) {
  try {
    await ensureJavascriptTools();
    const sourceDir = path.resolve(dir);
    const outputDir = process.cwd();
    const outputPrefix = `${outputDir}/`;
    if (!isDirectory(sourceDir)) {
      shell.echo(`${symbols.error} tx protocol source folder ${sourceDir} not exists`);
      process.exit(1);
    }

    const configFile = path.join(sourceDir, 'config.yml');
    if (!isFile(configFile)) {
      shell.echo(`${symbols.error} tx protocol config file ${configFile} not exists`);
      process.exit(1);
    }

    const config = yaml.parse(fs.readFileSync(configFile).toString());
    const { name, version, proto } = config;
    const protoFile = path.join(sourceDir, proto);
    shell.echo(`${symbols.info} protocol meta: ${JSON.stringify({ name, version })}`);
    shell.echo('');

    // 0. prepare compile dir
    const targetDir = path.join(outputDir, '.compiled');
    shell.exec(`rm -rf ${targetDir}`, { silent: true });
    shell.exec(`mkdir ${targetDir}`);

    // 1. detect language
    const supportedLangs = ['elixir', 'javascript'];
    const targetLangs = targets
      .split(',')
      .map(x => x.trim())
      .filter(x => supportedLangs.includes(x));

    const params = { sourceDir, targetDir, config, configFile, protoFile, outputPrefix };

    // 2. compile elixir
    if (targetLangs.includes('elixir')) {
      await compileElixir(params);
    }

    // 3. compile javascript
    if (targetLangs.includes('javascript')) {
      await compileJavascript(params);
    }
  } catch (err) {
    console.log(err);
  }
}

exports.run = main;
exports.execute = main;
