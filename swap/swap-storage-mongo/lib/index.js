/* eslint-disable no-bitwise */
/* eslint-disable no-param-reassign */
/* eslint-disable no-underscore-dangle */
const MongoClient = require('mongodb');
const StorageInterface = require('@arcblock/swap-storage');

class MongoSwapStorage extends StorageInterface {
  /**
   * Creates an instance of MongoSwapStorage.
   *
   * @class
   * @param {Object} options { collection, url }
   * @param {string} options.url - mongodb connection string
   * @param {string} [options.collection='abt_forge_swaps'] - which collection to store the swap records
   */
  constructor(options) {
    options = options || {};

    super(options);

    this.collectionName = options.collection || 'abt_forge_swaps';
    this.options = options;

    this.changeState('init');

    const newConnectionCallback = (err, client) => {
      if (err) {
        this.connectionFailed(err);
      } else {
        this.handleNewConnectionAsync(client);
      }
    };

    if (options.url) {
      // New native connection using url + mongoOptions
      const _options = options.mongoOptions || {};
      if (typeof _options.useNewUrlParser !== 'boolean') {
        _options.useNewUrlParser = true;
      }
      MongoClient.connect(options.url, _options, newConnectionCallback);
    } else if (options.mongooseConnection) {
      // Re-use existing or upcoming mongoose connection
      if (options.mongooseConnection.readyState === 1) {
        this.handleNewConnectionAsync(options.mongooseConnection);
      } else {
        options.mongooseConnection.once(
          'open',
          () => this.handleNewConnectionAsync(options.mongooseConnection)
          // eslint-disable-next-line function-paren-newline
        );
      }
    } else if (options.client) {
      this.handleNewConnectionAsync(options.client);
    } else if (options.clientPromise) {
      options.clientPromise
        .then(client => this.handleNewConnectionAsync(client))
        .catch(err => this.connectionFailed(err));
    } else {
      throw new Error('Connection strategy not found');
    }

    this.changeState('connecting');
  }

  connectionFailed(err) {
    this.changeState('disconnected');
    throw err;
  }

  handleNewConnectionAsync(client) {
    this.client = client;
    this.db = typeof client.db !== 'function' ? client.db : client.db();
    this.setCollection(this.db.collection(this.collectionName));
    this.changeState('connected');
  }

  changeState(newState) {
    if (newState !== this.state) {
      this.state = newState;
      this.emit(newState);
    }
  }

  setCollection(collection) {
    this.collectionReadyPromise = undefined;
    this.collection = collection;

    return this;
  }

  collectionReady() {
    let promise = this.collectionReadyPromise;
    if (!promise) {
      promise = new Promise((resolve, reject) => {
        if (this.state === 'connected') {
          return resolve(this.collection);
        }
        if (this.state === 'connecting') {
          return this.once('connected', () => resolve(this.collection));
        }
        return reject(new Error('Not connected'));
      });
      this.collectionReadyPromise = promise;
    }
    return promise;
  }

  /**
   * Create new atomic-swap order, traceId should be generated by user
   *
   * @method
   * @param {string} traceId
   * @param {object} initialAttributes
   * @returns {Promise<object>}
   */
  create(traceId, initialAttributes = {}) {
    return this.update(traceId, initialAttributes);
  }

  /**
   * Get an atomic-swap order by traceId
   *
   * @method
   * @param {string} traceId - the uuid of the swap order
   * @returns {Promise<object>} the atomic-swap-order
   */
  read(traceId) {
    return this.collectionReady().then(collection => collection.findOne({ traceId }));
  }

  /**
   * Finalize the payload of atomic-swap
   *
   * @method
   * @param {string} traceId
   * @param {object} payload
   * @returns {Promise<object>}
   */
  finalize(traceId, payload) {
    Object.keys(payload).forEach(x => {
      if (!this.payloadFields.includes(x)) {
        delete payload[x];
      }
    });

    return this.collectionReady()
      .then(collection => collection.updateOne({ traceId }, { $set: payload }))
      .then(rawResponse => {
        if (rawResponse.result) {
          rawResponse = rawResponse.result;
        }

        this.emit('finalize', Object.assign({ traceId }, payload));

        return this.read(traceId);
      });
  }

  /**
   * Update the status of an atomic-swap order, will not allow payload fields to be updated
   *
   * @method
   * @param {string} traceId
   * @param {object} updates
   * @returns {Promise<object>}
   */
  update(traceId, updates) {
    this.payloadFields.forEach(x => {
      delete updates[x];
    });

    updates.updatedAt = new Date();

    return this.collectionReady()
      .then(collection => collection.updateOne({ traceId }, { $set: updates }, { upsert: true }))
      .then(rawResponse => {
        if (rawResponse.result) {
          rawResponse = rawResponse.result;
        }
        if (rawResponse && rawResponse.upserted) {
          this.emit('create', traceId);
        } else {
          this.emit('update', traceId);
        }

        const payload = Object.assign({ traceId }, updates);

        // Allow external code to hook into events
        if (updates.status) {
          this.emit(updates.status, payload);
        }

        return payload;
      });
  }

  /**
   * Delete atomic swap order by traceId
   *
   * @method
   * @param {string} traceId
   * @returns void
   */
  delete(traceId) {
    return this.collectionReady()
      .then(collection => collection.deleteOne({ traceId }))
      .then(() => this.emit('destroy', traceId));
  }

  /**
   * Find atomic swap records by status
   *
   * @method
   * @param {string} status - check out list of supported status here
   * @returns {Promise<Array>}
   * TODO: add pagination for this
   */
  listByStatus(status) {
    return this.collectionReady().then(collection => collection.find({ status }));
  }

  /**
   * Find atomic swap records by offer address and status
   *
   * @method
   * @param {string} address
   * @param {string} [status='']
   * @returns {Promise<Array>}
   * TODO: add pagination for this
   */
  listByOfferAddress(address, status = '') {
    const conditions = { offerAddress: address };
    if (status) {
      conditions.status = status;
    }
    return this.collectionReady().then(collection => collection.find(conditions));
  }

  /**
   * Find atomic swap records by demand address and status
   *
   * @method
   * @param {string} address
   * @param {string} [status='']
   * @returns {Promise<Array>}
   * TODO: add pagination for this
   */
  listByDemandAddress(address, status = '') {
    const conditions = { demandAddress: address };
    if (status) {
      conditions.status = status;
    }
    return this.collectionReady().then(collection => collection.find(conditions));
  }

  // purge(ttl = 24 * 60 * 60 * 1000) {
  //   return this.collectionReady().then(collection =>
  //     collection.deleteMany({ status: 'not_started', createdAt: {} })
  //   );
  // }

  close() {
    if (this.client) {
      this.client.close();
    }
  }
}

module.exports = MongoSwapStorage;
